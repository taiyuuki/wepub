"use strict";var e=require("./subfile-4d4adfc1.js"),t=require("fs"),s=require("archiver");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}require("dayjs");var a=i(t),o=i(s);module.exports=class{metadata;coverImage;showContents;sections;css;filesForTOC;customFile;images;runtime;_generateContentsCallback;constructor(e){this.metadata={},this.coverImage={},this.showContents=!0,this.sections=[],this.css="",this.filesForTOC=[],this.customFile=[],this.images=[],this.runtime="node",e&&this.setMeta(e)}_verify(){const t=["id","title","author","cover"];if(e.isEmptyObj(this.metadata))throw new Error("Missing metadata, You can use the setMeta function to set it.");{const e=this.metadata;t.forEach((t=>{const s=e[t];if(null==s||void 0===s||""===s.toString().trim())throw new Error(`Missing required metadata: ${t}`)}))}}setMeta(e){Object.assign(this.metadata,e),this.showContents=e.showContents??!0,e.cover&&this.addCover(e.cover),e.images&&this.addImagesAll(e.images)}addCover(t){this.coverImage="string"==typeof t?{name:e.getImageFileName(t),data:t}:{name:t.name,data:t.path}}setContents(e){this._generateContentsCallback=e}addImage(t){"string"==typeof t?this.images.push({name:e.getFileName(t),data:t}):this.images.push({name:t.name,data:t.path})}addImagesAll(e){e.forEach((e=>{this.addImage(e)}))}addSection(e){let{title:t,overrideFilename:s,content:i,isFrontMatter:a,excludeFromContents:o}=e;if(null==s||void 0===s||""===s.toString().trim()){s=`s${this.sections.length+1}`}s=`${s}.xhtml`,this.sections.push({title:t,content:i,excludeFromContents:o||!1,isFrontMatter:a||!1,overrideFilename:s})}addSectionsAll(e){e.forEach((e=>{this.addSection(e)}))}addCustomFile(e){this.customFile.push(e)}getSectionsCount(){return this.sections.length}addCss(e){this.css=e}genUuid(){return e.genUuid()}async build(s,i){this._verify();const n=e.getFilesForEPUB(this),r=e.getFolder(s);let d=e.getFileName(s);d.endsWith(".epub")||(d+=".epub"),await t.promises.mkdir(r).catch((e=>{if(e&&"EEXIST"!==e.code)throw e}));const c=a.default.createWriteStream(`${r}/${d}`),h=o.default("zip",{store:!1});h.on("error",(e=>{throw e})),i&&h.on("progress",(e=>{i(100*e.entries.processed/n.length)})),h.pipe(c);for await(const e of n){"OEBPF/images"===e.folder&&(e.content=await t.promises.readFile(e.content));const s=e.folder.length>0?`${e.folder}/${e.name}`:e.name;h.append(e.content,{name:s,store:!e.compress})}h.finalize()}};
